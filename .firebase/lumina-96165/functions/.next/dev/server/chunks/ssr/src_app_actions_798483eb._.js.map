{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IASsB,sBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAmEsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAkHsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA4IsB,uBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA0KsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA0OsB,mBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA2QsB,sBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA4SsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA6VsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAiXsB,mBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///Users/chepuriharikiran/Desktop/github/lumina-ai-learning/src/app/actions/data.ts"],"sourcesContent":["'use server';\n\nimport clientPromise from '@/lib/mongodb';\nimport { ObjectId } from 'mongodb';\n\nconst DB_NAME = 'test';\n\n// --- Student Actions ---\n\nexport async function getStudentDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get User\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Enrolled Courses (via Progress) with Course Details\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed' // Keep track of this\n                }\n            }\n        ]).toArray();\n\n        // Calculate Streak (Max streak from progress)\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n\n        // Calculate Overall Mastery\n        const avgMastery = progressDocs.length > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / progressDocs.length)\n            : 0;\n\n        return {\n            currentStreak,\n            enrolledCourses: progressDocs,\n            overallMastery: avgMastery,\n            recentActivity: []\n        };\n    } catch (e) {\n        console.error('Error fetching student dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getEnrolledCourses(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        // Aggregate Progress with Course Details\n        const courses = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    let: { courseId: '$courseId' },\n                    pipeline: [\n                        { $match: { $expr: { $eq: ['$id', '$$courseId'] } } }\n                    ],\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    id: '$courseDetails.id',\n                    name: '$courseDetails.name',\n                    description: '$courseDetails.description',\n                    thumbnail: '$courseDetails.thumbnail',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        return courses;\n\n    } catch (e) {\n        console.error('Error fetching enrolled courses:', e);\n        return [];\n    }\n}\n\n// --- Profile & Progress Actions ---\n\nexport async function getStudentProfile(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        return {\n            name: user.name,\n            email: user.email,\n            avatar: user.avatar,\n            role: user.role,\n            joinedDate: user.createdAt,\n            // Mock extended fields if missing\n            bio: user.bio || \"Passionate learner on Lumina.\",\n            skills: user.skills || ['Learning', 'Growth'],\n            location: user.location || 'Online',\n            level: 5 // Calculate based on XP/Progress later\n        };\n    } catch (e) {\n        console.error(\"Error fetching profile\", e);\n        return null;\n    }\n}\n\nexport async function updateStudentProfile(email: string, data: any) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const updateData: any = {\n            name: data.name,\n            username: data.username, // New field\n            phone: data.phone,       // New field\n            // Don't update email for now as it identifies the user\n            // email: data.email \n        };\n\n        // Only update avatar if provided (and not empty)\n        if (data.avatar) {\n            updateData.avatar = data.avatar;\n        }\n\n        await db.collection('users').updateOne(\n            { email },\n            { $set: updateData }\n        );\n\n        return { success: true };\n    } catch (e) {\n        console.error(\"Error updating profile\", e);\n        return { success: false, error: 'Failed to update profile' };\n    }\n}\n\nexport async function getStudentProgress(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        const progressDocs = await db.collection('progress').aggregate([\n            { $match: { userId: user._id } },\n            {\n                $lookup: {\n                    from: 'courses',\n                    localField: 'courseId',\n                    foreignField: 'id',\n                    as: 'courseDetails'\n                }\n            },\n            { $unwind: '$courseDetails' },\n            {\n                $project: {\n                    _id: 0,\n                    courseName: '$courseDetails.name',\n                    progress: '$progress',\n                    mastery: '$mastery',\n                    streak: '$streak',\n                    lastAccessed: '$lastAccessed'\n                }\n            }\n        ]).toArray();\n\n        // Calculate Stats\n        const totalCourses = progressDocs.length;\n        const currentStreak = progressDocs.reduce((acc, curr) => Math.max(acc, curr.streak || 0), 0);\n        const avgAccuracy = totalCourses > 0\n            ? Math.round(progressDocs.reduce((acc, curr) => acc + (curr.mastery || 0), 0) / totalCourses)\n            : 0;\n\n        // Mock XP based on progress\n        const totalXP = progressDocs.reduce((acc, curr) => acc + ((curr.progress || 0) * 10), 0);\n\n        // Mock Weekly Activity (Random for now)\n        const weeklyActivity = [45, 60, 30, 90, 120, 60, 0];\n\n        return {\n            stats: {\n                currentStreak,\n                totalXP,\n                avgAccuracy,\n                level: Math.floor(totalXP / 1000) + 1,\n                learningTime: 'Mock 48h'\n            },\n            weeklyActivity,\n            recentCourses: progressDocs.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime()).slice(0, 3)\n        };\n\n    } catch (e) {\n        console.error(\"Error fetching progress\", e);\n        return null;\n    }\n}\n\n// --- Community Actions ---\n\nexport async function getCommunityData(channelId: string = 'general') {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        // Get Channels\n        const channels = await db.collection('community_channels').find({}).toArray();\n\n        // Get Messages for active channel\n        const messages = await db.collection('community_messages')\n            .find({ channelId })\n            .sort({ createdAt: 1 })\n            .limit(50)\n            .toArray();\n\n        // Transform _id to string for client\n        return {\n            channels: channels.map(c => ({ ...c, _id: c._id.toString() })),\n            messages: messages.map(m => ({\n                ...m,\n                _id: m._id.toString(),\n                userId: m.userId.toString()\n            }))\n        };\n\n    } catch (e) {\n        console.error('Error fetching community data:', e);\n        return { channels: [], messages: [] };\n    }\n}\n\n// --- Teacher Actions ---\n\nexport async function getTeacherDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return null;\n\n        // Get Courses taught by this teacher\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n\n        // Calculate Total Students (Sum of enrolledCount)\n        const totalStudents = courses.reduce((acc, curr) => acc + (curr.enrolledCount || 0), 0);\n\n        return {\n            courses: courses.map(c => ({\n                id: c.id,\n                name: c.name,\n                enrolled: c.enrolledCount,\n                thumbnail: c.thumbnail\n            })),\n            totalStudents,\n            activeCourses: courses.length,\n            // Mock other stats for now\n            hoursTaught: 120,\n            avgRating: 4.8\n        };\n    } catch (e) {\n        console.error('Error fetching teacher dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getTeacherStudents(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const user = await db.collection('users').findOne({ email });\n        if (!user) return [];\n\n        const courses = await db.collection('courses').find({ instructorId: user._id }).toArray();\n        const courseIds = courses.map(c => c.id);\n\n        if (courseIds.length === 0) return [];\n\n        const progressDocs = await db.collection('progress').find({ courseId: { $in: courseIds } }).toArray();\n        const studentIds = [...new Set(progressDocs.map(p => p.userId))];\n\n        if (studentIds.length === 0) return [];\n\n        const students = await db.collection('users').find({ _id: { $in: studentIds } }).toArray();\n\n        return students.map(student => {\n            const studentProgress = progressDocs.filter(p => p.userId.toString() === student._id.toString());\n            const coursesTaken = courses.filter(c => studentProgress.some(p => p.courseId === c.id));\n\n            const avgProgress = studentProgress.length > 0\n                ? Math.round(studentProgress.reduce((acc, curr) => acc + (curr.progress || 0), 0) / studentProgress.length)\n                : 0;\n\n            const lastActive = studentProgress.sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime())[0]?.lastAccessed;\n\n            return {\n                id: student._id.toString(),\n                name: student.name,\n                email: student.email,\n                avatar: student.avatar,\n                courses: coursesTaken.map(c => c.name),\n                progress: avgProgress,\n                lastActive: lastActive || student.createdAt\n            };\n        });\n\n    } catch (e) {\n        console.error('Error fetching teacher students:', e);\n        return [];\n    }\n}\n\n// --- Admin Actions ---\n\nexport async function getAdminDashboard(email: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const usersCount = await db.collection('users').countDocuments();\n        const coursesCount = await db.collection('courses').countDocuments();\n        // Mock revenue/system health\n        return {\n            totalUsers: usersCount,\n            totalCourses: coursesCount,\n            systemHealth: '98%',\n            securityAlerts: 0\n        };\n    } catch (e) {\n        console.error('Error fetching admin dashboard:', e);\n        return null;\n    }\n}\n\nexport async function getUsersForAdmin() {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const users = await db.collection('users').find({}).toArray();\n\n        return users.map(user => ({\n            id: user._id.toString(),\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            status: user.status,\n            createdAt: user.createdAt,\n            avatar: user.avatar\n        }));\n    } catch (e) {\n        console.error('Error fetching users for admin:', e);\n        return [];\n    }\n}\n\nexport async function getCourseDetails(courseId: string) {\n    try {\n        const client = await clientPromise;\n        const db = client.db(DB_NAME);\n\n        const course = await db.collection('courses').findOne({ id: courseId });\n        if (!course) return null;\n\n        // Ensure serialized return\n        return {\n            id: course.id,\n            name: course.name,\n            description: course.description,\n            thumbnail: course.thumbnail,\n            instructorId: course.instructorId ? course.instructorId.toString() : null,\n            expandedDescription: course.expandedDescription || \"No detailed description available.\",\n            modules: course.modules || [],\n            // Mock dynamic stats if missing\n            rating: 4.8,\n            students: course.enrolledCount || 120,\n            duration: '8 weeks'\n        };\n    } catch (e) {\n        console.error('Error fetching course details:', e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAuYsB,mBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}}]
}